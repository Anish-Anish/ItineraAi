import sys
import uuid
from app.agents.planner import get_structured_trip_details
from app.agents.planner import  run_step2
from app.agents.planner import  process_spots
from app.agents.planner import  optimize_day_plan
from app.agents.planner import  format_itinerary_with_llm
from app.agents.planner import  run_itinerary_pipeline
from typing import TypedDict, Annotated, List, Literal, Any, Dict
from langgraph.graph import StateGraph, START
from langgraph.graph.message import add_messages
from langchain_core.messages import HumanMessage, AIMessage, SystemMessage

from app.external.amadeus.flight.flight_details import get_iata_code_for_city, get_amadeus_token

from langgraph.types import Command
from pydantic import BaseModel, Field
import os
from dotenv import load_dotenv
import json
from app.external.google_maps.bus import get_bus_routes_json
from app.external.google_maps.accomdation import find_best_nearby_hotels
import requests
from datetime import datetime
# ------------------------------------------


from app.agents.llm_init import get_llm
from app.database.chat_storage import get_conversation_messages
from app.agents.initial_agent_executor import _initial_agent
from app.agents.general_chat_agent_executor import general_chat_agent

load_dotenv()



API_KEY = os.environ.get('AMADEUS_API_KEY')
API_SECRET = os.environ.get('AMADEUS_API_SECRET')
USD_TO_INR_RATE = 88.23

TOKEN_URL = 'https://test.api.amadeus.com/v1/security/oauth2/token'
FLIGHT_SEARCH_URL = 'https://test.api.amadeus.com/v2/shopping/flight-offers'
LOCATION_SEARCH_URL = 'https://test.api.amadeus.com/v1/reference-data/locations'



class DayItinerarySchema(BaseModel):
    time: str = Field(description="Time of the day (e.g., 'Morning', '10:00 AM').")
    activity: str = Field(description="Detailed activity description.")
    location: str = Field(description="Location or place name.")


class TravelPlanSchema(BaseModel):
    id: str = Field(description="Unique ID for this plan (will be generated by Python).")
    title: str = Field(description="A catchy, short title for the plan.")
    short_desc: str = Field(description="A concise, 15-word description of the plan's focus.")
    duration: str = Field(description="The length of the trip (e.g., '5 Days / 4 Nights').")
    budget: str = Field(description="The estimated total cost (e.g., 'â‚¹25,000' or 'Moderate').")
    highlights: List[str] = Field(description="3 unique selling points or key attractions of this itinerary.")
    days: List[DayItinerarySchema] = Field(description="A detailed, day-by-day itinerary of activities.")


class CityExtractionSchema(BaseModel):
    origin_city: str = Field(description="The starting city for the bus trip.")
    destination_city: str = Field(description="The destination city for the bus trip.")


class Itineraries(BaseModel):
    plans: List[TravelPlanSchema] = Field(description="A list containing exactly three distinct travel plans.")


class FlightOptionSchema(BaseModel):
    id: str = Field(description="Unique ID for the flight option.")
    carrier: str = Field(description="Airline name or code.")
    flight_number: str = Field(description="Full flight code (e.g., AA123).")
    departure_time: str = Field(description="Departure time (HH:MM).")
    arrival_time: str = Field(description="Arrival time (HH:MM).")
    origin_iata: str = Field(description="Departure airport IATA code.")
    destination_iata: str = Field(description="Arrival airport IATA code.")
    duration: str = Field(description="Total flight duration (e.g., 1H 15M).")
    price_inr: float = Field(description="Total price in Indian Rupees (INR).")
    is_direct: bool = Field(description="True if the flight is direct.")


class FlightOptions(BaseModel):
    flight_options: List[FlightOptionSchema] = Field(description="A list of the top 5 flight options.")



class State(TypedDict):
    messages: Annotated[list, add_messages]
    conversation_id: str
    user_query: str
    itinerary_plans: List[Dict[str, Any]]
    flight_data: List[Dict[str, Any]]
    selected_plan: Dict[str, Any]
    travel_bookings: Dict[str, Any]
    current_agent: str
    execution_status: str

    booking_params: Dict[str, Any]
    acomdation:Dict[str,Any]

    conversation_context: Dict[str, Any]

    origin_city : str
    destination_city : str
    departure_date : str
    adults : int
    number_of_days : int
    scenario : str
    clarify_question_status : bool
    clarify_question : str
    initial_agent_done: bool


def Supervisor(state: State) -> Command[Literal["initialAgent","Iterationagent", "FlightBookingagent", "GeneralChatagent","BusBookingAgent", "AccomodationAgent", "END"]]:

    print(" - "*50)
    print("\n Im inside supervisor\n")
    print(" - " * 50)

    messages = state["messages"]
    conversation_messages_list = get_conversation_messages(state["conversation_id"])
    #"initialAgent": 'This agent should be called only if the user query is about trip plan/ flight/ hotel Accomodation/ bus related. This agent will collect all the necessary inputs for the further booking agents requires. ',

    member_dict = {
        "initialAgent": 'This agent should be called only if the user query is about trip plan/ flight/ hotel accommodation/ bus related. This agent will collect all the necessary inputs for the further agents requires.',
        "Iterationagent": 'This agent is used to make or create an itinerary. Use this if the user asks for a plan, itinerary, or trip suggestion.',
        'FlightBookingagent': 'Specialized agent to **handle flight/train/bus booking queries**, transportation arrangements, and travel logistics. Use this if the user asks to **book, find options, or finalize a flight/trip** from one city to another.',
        'GeneralChatagent': 'Use this for any general greeting, thanks, or simple non-planning, non-booking queries. This agent will summarize and give more details if user requested.',
        "BusBookingAgent": 'Specialized agent to **handle bus route search and booking queries**. Use this specifically if the user asks to **book or find options for a BUS** trip from one city to another.',
        "AccommodationAgent": 'Specialized agent to research, recommend, and facilitate the booking of hotels and temporary stays (resorts, hostels, etc.) based on a target location. Use this if the user asks to find, search, or book accommodation or lodging options.'
    }

    worker_info = ""
    for member, description in member_dict.items():
        worker_info.join(f"worker:{member}\nDescription:{description}")
    worker_info.join("worker:END \n Description:If the user query is complete or requires no further action from the agents.")

    initial_agent_done = state.get("initial_agent_done")

    prompt  = f"""
            You are a supervisor Agent orchestrating a travel planning workflow agent. 
            Based on the user's last message or overall goal, decide which agent needs to be invoked next. 
            Available Agents: {worker_info} Based on the current chat history (especially the user's latest query), 
            IMPORTANT RULE (DO NOT BREAK):
                1. If the user query is related to:
                    - trip planning itinerary
                    - flight
                    - accommodation
                    - bus
                and then call the initial agent only if the agent is not executed to collect details .
                ignore this agent if that is executed. decide based on the current status.
                the status is Initial agent execution status: {initial_agent_done},
            
            if this agent executed successfully then move to other agent. 
            the last 4 conversation between the user and ai is : {conversation_messages_list[:5]}
            what is the next logical step?
"""


    m1 = [
        SystemMessage(content=prompt),
        HumanMessage(content=f"""The user query: {state["user_query"]}""")
    ]

    class Router(TypedDict):
        next: Annotated[
            Literal[
               "initialAgent", "Iterationagent", "FlightBookingagent", "GeneralChatagent", "BusBookingAgent", "AccomodationAgent", "END"], "worker agent to route to next or route to END"]
        reasoning: Annotated[str, "Support proper reasoning for routing to the worker"]

    try:
        result = get_llm().with_structured_output(Router).invoke(m1)
    except Exception as e:
        print(f"Supervisor LLM Error: {e}")
        return Command(goto="END",
                       update={"messages": messages + [AIMessage(content=f"Supervisor failed to route: {e}")]})

    goto = result["next"]
    reasoning = result["reasoning"]

    print(f" - - > Supervisor LLM goto: {goto}")
    print(f" - - > Supervisor LLM Reasoning: {reasoning}")

    log = {
        "supervisor": {
            "selected_agent": goto,
            "reasoning": reasoning
        }
    }
    messages.append(AIMessage(content=json.dumps(log)))

    return Command(goto=goto, update={"messages": messages})



def initialagent(state:State) -> Command[Literal["Supervisor"]]:
    print(" - " * 50)
    print("\n Im inside initial agent\n")
    print(" - " * 50)

    (origin_city, destination_city, departure_date, adults,
     number_of_days, scenario, clarify_question_status, clarify_question,
     initial_agent_done, rewritten_query) = _initial_agent(state)

    print(f"initial agent status : {initial_agent_done}")
    print(f"initial agent clarify question : {clarify_question}")

    user_query = state["user_query"]

    if clarify_question:
        goto = "END"
        ai_msg = AIMessage(content=json.dumps({"initial_agent": f"Initial agent still needs to ask some question, not completely executed."}))

        return Command(goto=goto,
                       update={
                           "clarify_question_status": clarify_question_status,
                           "clarify_question": clarify_question,
                           "messages": state["messages"] + [ai_msg],
                           "initial_agent_done": initial_agent_done,
                           "user_query": rewritten_query
                       })
    else:
        ai_msg = AIMessage(content=json.dumps({"initial_agent": f"completed for the user question: {user_query},"}))

        goto = "Supervisor"
        return Command(goto=goto,
                       update={
                           "messages": state["messages"] + [ai_msg],
                           "origin_city": origin_city,
                           "destination_city": destination_city,
                           "departure_date": departure_date,
                           "adults": adults,
                           "number_of_days": number_of_days,
                           "scenario": scenario,
                           "clarify_question_status": clarify_question_status,
                           "clarify_question": clarify_question,
                           "initial_agent_done": initial_agent_done,
                           "user_query": rewritten_query
                       })



def Iterationagent(state: State) -> Command[Literal["Supervisor"]]:

    print(" * " * 50)
    print("\n Im inside iteration agent\n")
    print(" * " * 50)

    messages = state["messages"]
    user_query = state["user_query"]
    try:
        import json
        from colorama import Fore, Style
        import asyncio
        from datetime import datetime
        import json

        print(f"user query is : {user_query}\n\n")

        def log_time(step_name, start_time, end_time):
            duration = (end_time - start_time).total_seconds()
            print(f"{Fore.MAGENTA}{step_name} took {duration:.2f} seconds{Style.RESET_ALL}\n")
            return duration

        overall_start = datetime.now()
        print(f"{Fore.YELLOW} Process started at: {overall_start.strftime('%Y-%m-%d %H:%M:%S')}{Style.RESET_ALL}\n")

        print(f"{Fore.CYAN}{'-' * 50}\n STEP 1: Understanding User Intent\n{'-' * 50}{Style.RESET_ALL}")
        start_step1 = datetime.now()
        trip1 = get_structured_trip_details(user_query)

        end_step1 = datetime.now()
        print("\nStructured Intent Response:\n")
        print(trip1.model_dump_json(indent=2))
        step1_time = log_time("STEP 1 (Understanding User Intent)", start_step1, end_step1)

        print(
            f"\n{Fore.CYAN}{'-' * 50}\n STEP 2: Destination + Spots Search + Hotel Search\n{'-' * 50}{Style.RESET_ALL}")
        start_step2 = datetime.now()
        step2 = asyncio.run(run_step2(trip1.model_dump()))
        end_step2 = datetime.now()
        print(json.dumps(step2, indent=2))
        step2_time = log_time("STEP 2 (Destination + Spots + Hotels)", start_step2, end_step2)

        print(f"\n{Fore.GREEN}{'-' * 50}\n STEP 3: Distance + Cost Estimation\n{'-' * 50}{Style.RESET_ALL}")
        start_step3 = datetime.now()
        step3 = asyncio.run(process_spots(step2))
        end_step3 = datetime.now()
        print(json.dumps(step3, indent=2))
        step3_time = log_time("STEP 3 (Distance + Cost Estimation)", start_step3, end_step3)

        print(f"\n{Fore.YELLOW}{'-' * 50}\n Bridge: Step 3 â†’ Step 4 Conversion\n{'-' * 50}{Style.RESET_ALL}")
        start_step4 = datetime.now()
        python_output = optimize_day_plan(step2, step3)
        final_itinerary = format_itinerary_with_llm(python_output, user_query)
        end_step4 = datetime.now()
        print("\nLLM Formatted Itinerary:\n")
        print(json.dumps(final_itinerary, indent=2))
        step4_time = log_time("STEP 3 to 4 (Itinerary Optimization + LLM Formatting)", start_step4, end_step4)

        print(
            f"\n{Fore.MAGENTA}{'=' * 50}\n STEP 4 & 5 & STEP 6: Weather âœ“ Final Itinerary âœ“ Enhancements âœ“\n{'=' * 50}{Style.RESET_ALL}"
        )
        start_step5 = datetime.now()
        result = asyncio.run(run_itinerary_pipeline(final_itinerary))

        end_step5 = datetime.now()
        print("\n FINAL RESULT:\n")
        print(json.dumps(result, indent=2))
        step5_time = log_time("STEP 5â€“6 (Weather + Final Enhancements)", start_step5, end_step5)

        overall_end = datetime.now()
        overall_duration = (overall_end - overall_start).total_seconds()

        print(f"{Fore.GREEN} DONE! Your trip plan has been successfully generated ðŸ¥³âœ¨{Style.RESET_ALL}")
        print(f"{Fore.CYAN} Process finished at: {overall_end.strftime('%Y-%m-%d %H:%M:%S')}{Style.RESET_ALL}")
        print(f"{Fore.BLUE}TOTAL EXECUTION TIME: {overall_duration:.2f} seconds{Style.RESET_ALL}")

        # Summary of all step durations
        print(f"\n{Fore.WHITE}{'=' * 50}")
        print(f"Execution Time Summary:")
        print(f"  Step 1: {step1_time:.2f}s")
        print(f"  Step 2: {step2_time:.2f}s")
        print(f"  Step 3: {step3_time:.2f}s")
        print(f"  Step 3-4 convertor: {step4_time:.2f}s")
        print(f"  Step 4-5â€“6: {step5_time:.2f}s")
        print(f"{'-' * 50}")
        print(f" Total Time: {overall_duration:.2f}s")
        print(f"{'=' * 50}{Style.RESET_ALL}")

        log = {
            "Iterationagent": {
                "message": "Successfully generated three structured plans.",
                "status": "success",

            }
        }
        print('*'*50)
        print(f"plans as of now generated{result}")
        print('*' * 50)
        messages.append(AIMessage(content=json.dumps(log)))

        final_values = {
            "user_query": user_query,
            "all_itinearies" :[plan.get("itinerary", {}) for plan in result]
        }


        return Command(goto="END", update={"messages": messages, "itinerary_plans": result, "conversation_context":final_values})

    except Exception as e:
        print(f"Iteration Agent LLM Error: {e}")
        log = {
            "Iterationagent": {
                "message": f"Plan generation failed due to an LLM error: {e}",
                "status": "failure"
            }
        }
        messages.append(AIMessage(content=json.dumps(log)))
        return Command(goto="END", update={"messages": messages, "execution_status": "Plan generation failed."})





def BusBookingAgent(state:State)->Command[Literal["END"]]:
    print(" * " * 50)
    print("\n Im inside booking agent\n")
    print(" * " * 50)

    messages = state["messages"]
    origin_city = state["origin_city"]
    destination_city = state["destination_city"]


    print(f"Bus Booking Agent: Searching for bus routes: {origin_city} to {destination_city}...")
    try:
        bus_data = get_bus_routes_json(origin_city, destination_city)


        if "error" in bus_data:
            error_msg = bus_data['error']
            log = {"BusBookingAgent": {"status": "failure", "message": f"Bus search failed: {error_msg}"}}
            messages.append(AIMessage(content=json.dumps(log)))
            messages.append(AIMessage(
                content=f"I couldn't find any bus routes from **{origin_city}** to **{destination_city}**. The search system reported: {error_msg}"))
            return Command(goto="END", update={"messages": messages, "execution_status": "No bus routes found."})

        structured_buses = []

        log = {
            "BusBookingAgent": {
                "message": f"Found {len(bus_data)} bus route options. Displaying top {len(structured_buses)}.",
                "status": "success",
                "extracted_origin": origin_city,
                "extracted_destination": destination_city
            }
        }
        messages.append(AIMessage(content=json.dumps(log)))

        bus_list_str = "\n".join([
            f"- **{route['route_id']}** ({route['type']}): {route['total_time']}. First Bus: {route['segments'][0]['name']} from {route['segments'][0]['route'].split(' â†’ ')[0]}"
            for route in structured_buses
        ])

        chat_message = f" Here are the top bus route options from **{origin_city}** to **{destination_city}**:\n{bus_list_str}\n\nLet me know if you want details on a specific route!"
        messages.append(AIMessage(content=chat_message))

        return Command(goto="END", update={"messages": messages,
                                           "execution_status": "Bus search complete.","travel_bookings":bus_data})

    except Exception as e:
        print(f"Bus Agent Error: {e}")
        messages.append(
            AIMessage(content=json.dumps({"BusBookingAgent": {"status": "failure", "message": str(e)}})))
        messages.append(AIMessage(
            content="I couldn't complete the bus search. There was an internal error during the transit lookup."))
        return Command(goto="END", update={"messages": messages, "execution_status": "Internal error."})



def AccomodationAgent(state:State)-> Command[Literal["END"]]:
    print(" * " * 50)
    print("\n Im inside Accommodation agent\n")
    print(" * " * 50)

    messages=state["messages"]
    """
       Specialized agent to find and recommend the best accommodation options.

       Flow:
       1. Extract address from user query using an LLM.
       2. Call the external utility to find hotels.
       3. Update the state object with the structured results.
       4. Return control flow command "END".
       """
    print("\n--- AccommodationAgent STARTED ---")
    user_query = state.get("user_query", "No query provided.")
    extraction_prompt = f"""
        Analyze the following user query which is intended for accommodation booking.
    Strictly extract and return ONLY the primary location or full address for the search.
    If multiple locations are mentioned, return the most prominent one.
    Query: {user_query}
       """
    try:
        response = get_llm().invoke([SystemMessage(content=extraction_prompt), HumanMessage(content=user_query)])
        acoomdationdetails = response.content
    except Exception as e:
        print(f"General Chat LLM Error: {e}")
    result=find_best_nearby_hotels(acoomdationdetails)
    print(f"result from accomodation agent{result}")
    log = {
        "BusBookingAgent": {
            "message": f"Found Accomodation details for the user query",
            "status": "success",

        }
    }
    messages.append(AIMessage(content=json.dumps(log)))
    return Command(goto="END", update={"messages": messages,
                                       "execution_status": "Bus search complete.",
                                       "acomdation":result})



def FlightBookingagent(state: State) -> Command[Literal["END"]]:
    print(" * " * 50)
    print("\n Im inside Flight booking agent\n")
    print(" * " * 50)


    messages = state["messages"]

    origin_city = state["origin_city"]
    destination_city = state['destination_city']
    departure_date = state["departure_date"]
    adults = state["adults"]

    print(f"Flight Booking Agent: Searching for flights: {origin_city} to {destination_city} on {departure_date}...")

    try:

        client_id = os.getenv("AMADEUS_CLIENT_ID")
        client_secret = os.getenv("AMADEUS_CLIENT_SECRET")

        token = get_amadeus_token(client_id, client_secret)
        if not token: raise Exception("Failed to get Amadeus access token.")


        origin_iata = get_iata_code_for_city(token, origin_city)
        destination_iata = get_iata_code_for_city(token, destination_city)
        if not (origin_iata and destination_iata): raise Exception("Failed to find IATA codes for the cities.")

        flight_params = {
            'originLocationCode': origin_iata,
            'destinationLocationCode': destination_iata,
            'departureDate': departure_date,
            'adults': adults,
            'currencyCode': 'USD',
            'max': 5
        }

        flight_headers = {'Authorization': f'Bearer {token}'}
        flight_response = requests.get(FLIGHT_SEARCH_URL, headers=flight_headers, params=flight_params)
        flight_response.raise_for_status()
        flight_data = flight_response.json().get('data', [])

        if not flight_data:
            log = {"FlightBookingagent": {"status": "success", "message": "No flights found."}}
            messages.append(AIMessage(content=json.dumps(log)))
            messages.append(AIMessage(
                content=f"I couldn't find any direct flight options from {origin_city} to {destination_city} on {departure_date}."))
            return Command(goto="END", update={"messages": messages, "execution_status": "No flights found."})

        structured_flights = []
        for i, offer in enumerate(flight_data[:5]):
            price_usd = float(offer['price']['grandTotal'])
            price_inr = price_usd * USD_TO_INR_RATE

            itinerary = offer['itineraries'][0]
            segments = itinerary['segments']
            first_segment = segments[0]

            is_direct = len(segments) == 1

            structured_flights.append(FlightOptionSchema(
                id=str(uuid.uuid4()),
                carrier=first_segment['carrierCode'],
                flight_number=f"{first_segment['carrierCode']}{first_segment['number']}",
                departure_time=first_segment['departure']['at'].split('T')[1][:5],
                arrival_time=itinerary['segments'][-1]['arrival']['at'].split('T')[1][:5],
                origin_iata=first_segment['departure']['iataCode'],
                destination_iata=itinerary['segments'][-1]['arrival']['iataCode'],
                duration=itinerary['duration'].replace('PT', ''),  # e.g., '1H15M'
                price_inr=round(price_inr),
                is_direct=is_direct
            ).dict())

        log = {
            "FlightBookingagent": {
                "message": f"Found {len(structured_flights)} flight options.",
                "status": "success"
            }
        }
        messages.append(AIMessage(content=json.dumps(log)))

        chat_message = f"Here are the flight options from {origin_city} to {destination_city} on {departure_date} for you. Let me know if you need any further assistance!"
        messages.append(AIMessage(content=chat_message))

        return Command(goto="END", update={"messages": messages, "flight_data": structured_flights,
                                           "execution_status": "Flight search complete."})

    except requests.exceptions.HTTPError as e:
        print(f"API HTTP Error: {e}")
        error_message = f"An API error occurred while searching for flights. Please check the Amadeus API response details."
        messages.append(
            AIMessage(content=json.dumps({"FlightBookingagent": {"status": "failure", "message": error_message}})))
        messages.append(AIMessage(
            content="I'm sorry, I ran into an issue connecting to the flight system. Please check the cities and date format."))
        return Command(goto="END", update={"messages": messages, "execution_status": "API error."})
    except Exception as e:
        print(f"Flight Agent Error: {e}")
        messages.append(AIMessage(content=json.dumps({"FlightBookingagent": {"status": "failure", "message": str(e)}})))
        messages.append(AIMessage(content="I couldn't complete the flight search. Please try rephrasing your request."))
        return Command(goto="END", update={"messages": messages, "execution_status": "Internal error."})



def GeneralChatagent(state: State) -> Command[Literal["END"]]:
    print(" * " * 50)
    print("\n Im inside General chat agent\n")
    print(" * " * 50)

    messages = state["messages"]
    try:
        response = general_chat_agent(state)
        chat_response = response.content
    except Exception as e:
        print(f"General Chat LLM Error: {e}")
        chat_response = "I'm sorry, I'm having trouble with my chat services right now."

    log = {
        "GeneralChatagent": {
            "message": "Chat response generated.",
            "status": "success"
        }
    }
    messages.append(AIMessage(content=json.dumps(log)))
    messages.append(AIMessage(content=chat_response))

    return Command(goto="END", update={"messages": messages, "execution_status": "Chat complete."})




def compile_graph():

    def end_node(state: State):
        return state



    graph_builder = StateGraph(State)

    # Add all nodes
    graph_builder.add_node("initialAgent", initialagent)
    graph_builder.add_node("Supervisor", Supervisor)
    graph_builder.add_node("FlightBookingagent", FlightBookingagent)
    graph_builder.add_node("Iterationagent", Iterationagent)
    graph_builder.add_node("GeneralChatagent", GeneralChatagent)
    graph_builder.add_node("BusBookingAgent", BusBookingAgent)
    graph_builder.add_node("AccomodationAgent", AccomodationAgent)
    # graph_builder.add_node("END", lambda x: x)
    graph_builder.add_node("END", end_node)

    graph_builder.add_edge(START, "Supervisor")
    # graph_builder.add_edge("Supervisor", "initialAgent")
    # graph_builder.add_edge("Supervisor", "FlightBookingagent")
    # graph_builder.add_edge("Supervisor", "Iterationagent")
    # graph_builder.add_edge("Supervisor", "GeneralChatagent")
    # graph_builder.add_edge("Supervisor", "BusBookingAgent")
    # graph_builder.add_edge("Supervisor", "AccomodationAgent")
    graph_builder.add_edge("Iterationagent", "END")
    graph_builder.add_edge("FlightBookingagent", "END")
    graph_builder.add_edge("BusBookingAgent", "END")
    graph_builder.add_edge("GeneralChatagent", "END")
    graph_builder.add_edge("AccomodationAgent", "END")
    graph_builder.add_edge("initialAgent", "END")

    return graph_builder.compile()



langgraph_app = compile_graph()


# if __name__ == '__main__':
#     # This block is for testing the graph logic in isolation if needed
#     print("LangGraph module compiled successfully.")
#     query_in_english="help me to book me a hotel"
#     op=langgraph_app.invoke( {
#                 "messages": [HumanMessage(content=query_in_english)],
#                 "user_query": query_in_english
#             })
#     print(f"langraph op->>>>>>>>>>{op}")

# if __name__ == '__main__':
#     # This block is for testing the graph logic in isolation if needed
#     langgraph_app
#     print("LangGraph module compiled successfully.")